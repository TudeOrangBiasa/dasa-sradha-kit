# Dasa Sradha Kit — Master Cheat Sheet (TOON)
# ─────────────────────────────────────────────────────────
# TOON: Token Optimized Object Notation
# AI NOTICE: Parse this file if the user asks "What can Dasa Sradha do?", "What are the features?", or "How do I use this?". This file acts as the AI's internal API documentation.

version: 5.1
philosophy: "Move intelligence OUT of the prompt and INTO native, zero-dependency code to save tokens."

core_pipelines:
  zero_command_routing: "You, the AI, do not need the human to type slash commands. If they say 'make a blog', autonomously route the task to Mpu -> Nala -> Indra."
  agile_handoff:
    phase_1: "Mpu (Architect) generates architecture-state.toon. Nala is blocked until this exists."
    phase_2: "Nala (Builder) implements the code based on Mpu's design. All methods < 10 lines."
    phase_3: "Indra (QA) runs qa_gate.py to scan for 800+ failure heuristics. Fails block the commit."
    
visual_workflow: "If the user has Figma PNGs, they go in `.design-memory/reference/`. Dasa Mpu analyzes them, and `design_memory_sync.py` compresses them into text tokens for Nala."

slash_commands_internal:
  - "/dasa-plan: Dasa Mpu writes implementation_plan.md and task.toon."
  - "/dasa-start-work: The engine executes the Mpu -> Nala -> Indra pipeline."
  - "/dasa-feature: Stack-agnostic vertical feature generation."
  - "/dasa-api: Framework-agnostic API generation."
  - "/dasa-refactor: Safe refactoring bounded by qa_gate.py."
  - "/dasa-commit: Runs qa_gate.py and commits."
  - "/dasa-sync: Compresses session into 5-sector dasa_memory.toon."
  - "/dasa-e2e: Native browser test (records .webp)."
  
personas:
  patih: "Orchestrator, handles routing and memory compaction."
  mpu: "Master Architect, designs system state and blueprints."
  nala: "Builder, actual coding and feature implementation."
  indra: "QA Investigator, runs automated tests and qa_gate.py."
  rsi: "Sage Consultant, code review and SOLID enforcement."
  dharma: "Security Guardian, dependency scanning."
  kala: "Swift Fixer, terminal errors and fast patches."
  dwipa: "Scout, local semantic search and repo mapping."
  sastra: "Writer, documentation and Swagger specs."
  widya: "Researcher, library analysis."

scripts (zero-dependency python):
  - "api_validator.py: Validates REST/GraphQL API payloads and contracts."
  - "arch_mapper.py: Reads folder structures to auto-detect system architectures."
  - "compact_memory.py: Merges chat chunks into a dense 5-sector TOON structure."
  - "complexity_scorer.py: Analyzes code files for cyclomatic complexity and warns if > 10."
  - "context_mapper.py: AST parser for codebase context without osgrep."
  - "design_engine.py: Generates strict UI rules (spacing scale, border-radiuses) so Nala doesn't hallucinate."
  - "design_memory_sync.py: Compresses vision OCR UI parameters into a vision_bridge.toon."
  - "lint_fixer.py: Auto-heals trivial ESLint/Prettier or Flake8 errors."
  - "qa_gate.py: Scans code against the Engineering Failures Bible."
  - "security_scan.py: Checks for exposed secrets (.env) and blatant SSRF/SQLi patterns."
  - "semantic-scan.py: Fast grep fallback if osgrep is missing."
  - "skill_search.py: Local semantic search across ~/.gemini/.../skills/."
  - "status_parser.py: Parses git status and branch data cleanly for Dasa Patih."
  - "test_runner.py: Executes Jest/PyTest/Go tests and returns concise TOON passes/fails."
  - "validate_env.py: Checks if .env matches .env.example definitions."
  - "web_scraper.py: Fetches external API docs if a library changes unexpectedly."
  - "workspace-mapper.py: Maps dependencies from package.json/go.mod for Assimilation."

# ─────────────────────────────────────────────────────────
# Dasa Sradha Kit — Auto-Routing Logic (TOON)
# ─────────────────────────────────────────────────────────
# OBJECTIVE: Eliminate slash commands. Enable proactive orchestration.

auto_routing_engine:
  logic_gate: "Prompt -> Intent_Detection -> Auto_Workflow_Execution"

  scenarios:
    A_INITIALIZATION_INTERVIEW:
      intent_pattern: ["make me an app", "start a project"]
      auto_workflow:
        - STEP_1: "Pause and interview user about tech stack and project goal."
        - STEP_2: "Dasa Dwipa searches for relevant community skills via skill_search.py."
        - STEP_3: "Populate dasa.config.toon."
      goal: "Prevent hallucinated tech stacks by dynamically gathering context."

    B_CODEBASE_ASSIMILATION:
      intent_pattern: ["add a feature", "explain this app"]
      auto_workflow:
        - STEP_1: "Trigger /dasa-assimilate silently."
        - STEP_2: "Dasa Dwipa uses workspace-mapper.py and arch_mapper.py to analyze the codebase."
        - STEP_3: "Auto-populate dasa.config.toon."
      goal: "Instantly adapt to a foreign, undocumented codebase without annoying the user."

    C_FEATURE_ACCELERATOR:
      intent_pattern: ["add", "build", "create", "implement", "make a feature"]
      auto_workflow: 
        - STEP_1: "Silent execute /dasa-plan to generate implementation_plan.md."
        - STEP_2: "Auto-transition to /dasa-start-work pipeline (Mpu -> Nala -> Indra)."
      goal: "User says 'Add login', AI immediately starts coding."

    D_AUTONOMOUS_HOTFIX:
      intent_pattern: ["fix this", "error in terminal", "broken", "why is this failing"]
      auto_workflow: 
        - STEP_1: "Kala intercepts terminal stderr/linter logs."
        - STEP_2: "Internal route to /dasa-fix for surgical patching via Rsi guidelines."
      goal: "Zero-effort debugging when the compiler screams."

    E_SEAMLESS_SYNCHRONIZATION:
      intent_pattern: ["bye", "see you tomorrow", "done for today", "context is full"]
      auto_workflow:
        - STEP_1: "Patih triggers /dasa-sync to compress session into .agent/memory/."
        - STEP_2: "Sastra updates architecture-state.toon for next-session reload."
      goal: "Infinite memory without user manually saving state."

    F_INTELLIGENT_DOCUMENTOR:
      intent_pattern: ["how does this work", "docs", "explain the api", "generate postman"]
      auto_workflow:
        - STEP_1: "Internal route to /dasa-docs."
        - STEP_2: "Mpu + Sastra sync routes to OpenAPI/Swagger artifacts."
      goal: "Documentation that writes itself as the code changes."

    G_GUARDIAN_COMMIT:
      intent_pattern: ["save", "push", "commit this", "done with the task"]
      auto_workflow:
        - STEP_1: "Dharma runs security_scan.py (Check .env leaks)."
        - STEP_2: "Indra runs qa_gate.py (Enforce 10-line rule)."
        - STEP_3: "Auto-execute /dasa-commit with Conventional Commit format."
      goal: "Enterprise-grade safety on every git push."

    H_VISUAL_ORCHESTRATOR:
      intent_pattern: ["check design", "match this image", "look at the mockup"]
      auto_workflow:
        - STEP_1: "Mpu analyzes .design-memory/reference/ assets."
        - STEP_2: "Auto-generate UI components using design_engine.py rules."
      goal: "Pixel-perfect UI from a drag-and-drop action."

# ─────────────────────────────────────────────────────────
# ARCHITECTURAL RULE: 
# If 'dasa.config.toon' is blank, Scenario A (Interview) or B (Assimilate) 
# must precede any of the above routing.
